*submode.nvim.txt*        For Neovim >= 0.10.0       Last change: 2024 June 13

==============================================================================
Table of Contents                             *submode.nvim-table-of-contents*

1. submode.nvim                                    |submode.nvim-submode.nvim|
  - Warning                                |submode.nvim-submode.nvim-warning|
  - Requirements                      |submode.nvim-submode.nvim-requirements|
  - Introduction                      |submode.nvim-submode.nvim-introduction|
  - Installation                      |submode.nvim-submode.nvim-installation|
  - Examples                              |submode.nvim-submode.nvim-examples|
  - User Events                        |submode.nvim-submode.nvim-user-events|
  - APIS                                      |submode.nvim-submode.nvim-apis|

==============================================================================
1. submode.nvim                                    *submode.nvim-submode.nvim*

This plugin provide apis to create a submode and manipulate it.

These apis can be used on-the-fly: no need to call config like other plugin.


WARNING                                    *submode.nvim-submode.nvim-warning*

This plugin is in development stage and breaking changes may occure to apis. We
recommend you to pin version for prevent unexpected change.


REQUIREMENTS                          *submode.nvim-submode.nvim-requirements*

- Neovim >= 0.10.0


INTRODUCTION                          *submode.nvim-submode.nvim-introduction*

This plugin allow users to create submode, which has almost same keymaps as the
parent mode like normal, insert, etc, but some keymaps is changed and is
defined by user.

For example, when we try to move around windows, we need to press `<C-w>h`,
`<C-w>j`, `<C-w>k` and `<C-w>l` multiple times. Therefore, it would be useful
to be able to press `<C-w>` and then `hjkl` to move the window.

Fortunately, you can define such submode as follow.

>lua
    local submode = require("submode")
    submode.create("WinMove", {
        mode = "n",
        enter = "<C-w>",
        leave = { "q", "<ESC>" },
    }, function(default)
        default("h", "<C-w>h")
        default("j", "<C-w>j")
        default("k", "<C-w>k")
        default("l", "<C-w>l")
    end) -- WinMove is sealed here
<

This submode has default mappings `hjkl` for moving around windows, and you can
enter this submode by pressing `<C-w>` when in normal mode. Once you enter this
submode, you can use `hjkl`. You can leave from this submode by pressing `q` or
`escape`, and after that `hjkl` cannot be used to move windows anymore.

You can define default mappings by passing list of table, or manually call
`submode.default` and `submode.seal`

>lua
    -- Passing tables to define mappings.
    local submode = require("submode")
    submode.create("WinMove", {
        mode = "n",
        enter = "<C-w>",
        leave = { "q", "<ESC>" },
    }, {
        lhs = "h",
        rhs = "<C-w>h",
    }, {
        lhs = "j",
        rhs = "<C-w>j",
    }, {
        lhs = "k",
        rhs = "<C-w>k",
    }, {
        lhs = "l",
        rhs = "<C-w>l",
    }) -- WinMove is sealed here
<

>lua
    local submode = require("submode")
    submode.create("WinMove", {
        mode = "n",
        enter = "<C-w>",
        leave = { "q", "<ESC>" },
    })
    submode.default("WinMove", "h", "<C-w>h")
    submode.default("WinMove", "j", "<C-w>j")
    submode.default("WinMove", "k", "<C-w>k")
    submode.default("WinMove", "l", "<C-w>l")
    submode.seal("WinMove") -- Should be called to seal this submode to prevent unexpected `submode.default`
<

Ifyou call `submode.default` manually, you have to call `submode.seal` as the
submode must be sealed with it to prevent unexpected call of `submode.default`.

Once the submode is sealed, the submode can be exposed to outside safely: any
plugin can provide its own submode.

Next, sometimes you may want to add a mappings to exist submode to extend the
behavior of the submode. Is it possible in this plugin? The answer is yes.

For example, you have a submode defined as follow.

>lua
    local submode = require("submode")
    submode.create("test", {
        mode = "n",
        enter = "]",
        leave = { "q", "<ESC>" },
    }, function(default)
        default("1", function() vim.notify("1") end)
    end)
<

The submode doesn’t accept `submode.default` as it already sealed, so you
have to use `submode.set` instead to add mappings.

It means, if you want to add `2` to notify `2`, you can achieve it with the
following code.

>lua
    submode.set("test", "2", function() vim.notify("2") end)
<

This interface is compatible with `vim.keymap.set`, so you can easily define
mappings the way you are used to.

Just as neovim provides `vim.keymap.del`, this plugin provides its compatible
interface: `submode.del`. You can use it like as `vim.keymap.set`.

>lua
    submode.del("test", "2")
<

One additional notable point is that mappings created by `submode.create`, or
defined by `submode.default` doesn’t change even if `submode.set` and
`submode.del` is called in the order.

For example, if we call `submode.set("test", "1", "")`, this disable the
behavior of `1` in `test`, but if we call `submode.del("test", "1")` after
that, pressing `1` will notify `1`.


INSTALLATION                          *submode.nvim-submode.nvim-installation*

With lazy.nvim <https://github.com/folke/lazy.nvim>

>lua
    return {
        "pogyomo/submode.nvim",
        lazy = true,
        -- (recommended) specify version to prevent unexpected change.
        -- version = "5.2.0",
    }
<


EXAMPLES                                  *submode.nvim-submode.nvim-examples*

- Submode to switch to lsp-related keymaps.

>lua
    local submode = require("submode")
    
    submode.create("LspOperator", {
        mode = "n",
        enter = "<Space>l",
        leave = { "q", "<ESC>" },
    }, function(default)
        default("d", vim.lsp.buf.definition)
        default("D", vim.lsp.buf.declaration)
        default("H", vim.lsp.buf.hover)
        default("i", vim.lsp.buf.implementation)
        default("r", vim.lsp.buf.references)
    end)
<

- Enable keymaps which is appropriate for reading help when open help.

>lua
    local submode = require("submode")
    
    submode.create("DocReader", {
        mode = "n",
    }, function(default)
        default("<Enter>", "<C-]>")
        default("u", "<cmd>po<cr>")
        default("r", "<cmd>ta<cr>")
        default("U", "<cmd>ta<cr>")
        default("q", "<cmd>q<cr>")
    end)
    
    vim.api.nvim_create_augroup("DocReaderAugroup", {})
    vim.api.nvim_create_autocmd("BufEnter", {
        group = "DocReaderAugroup",
        callback = function()
            if vim.opt.ft:get() == "help" and not vim.bo.modifiable then
                submode.enter("DocReader")
            end
        end,
    })
    vim.api.nvim_create_autocmd({ "BufLeave", "CmdwinEnter" }, {
        group = "DocReaderAugroup",
        callback = function()
            if submode.mode() == "DocReader" then
                submode.leave()
            end
        end,
    })
<


USER EVENTS                            *submode.nvim-submode.nvim-user-events*

The following user events will be triggered.

- `SubmodeEnterPre`
    - Emitted when `submode.enter` called and before process anything.
    - `data` attribute will hold `name` for corresponding submode name.
- `SubmodeEnterPost`
    - Emitted when `submode.enter` called and after all process done.
    - `data` attribute will hold `name` for corresponding submode name.
- `SubmodeLeavePre`
    - Emitted when `submode.leave` called and before process anything.
    - `data` attribute will hold `name` for corresponding submode name.
- `SubmodeLeavePost`
    - Emitted when `submode.leave` called and after all process done.
    - `data` attribute will hold `name` for corresponding submode name.


APIS                                          *submode.nvim-submode.nvim-apis*

- `create(name, info, ...)`
    - Create a new submode.
    - `name: string` Name of this submode.
    - `info: table` Infomation of this submode. Have the following fields.
        - `mode: string` Parent mode of this submode like `"n"`, `"v"`, etc.
        - `show_mode?: boolean` False to suppress `mode()` returns the submode name.
        - `mode_name?: string | fun(): string` Change the value `mode()` returns.
        - `enter?: string | string[]` Keys to enter to this submode.
        - `leave?: string | string[]` Keys to leave from this submode.
        - `enter_cb?: function` Callback to be called when enter to submode.
        - `leave_cb?: function` Callback to be called when leave from submode.
        - `leave_when_mode_changed?: boolean` Whether leave from current submode or not when parent mode is changed i.e. changed normal mode to visual mode. Default is false.
        - `override_behavior?: string` Behavior when the submode already exist. Accept following strings.
            - `"error"` Throw error. This is default.
            - `"keep"` Keep current submode.
            - `"override"` Override old submode.
    - `...: table | function` Default mappings for this submode.
        - If a element is table, has a following fields:
            - `lhs: string` Lhs of mapping.
            - `rhs: string | fun():string?` Rhs of mapping. Can be function.
            - `opts?: table` Options of this mapping. Same as `opts` of `vim.keymap.set`.
        - If a element is function, the parameter is as follow:
            - `default: fun(lhs: string, rhs: string | function, opts?: table)` Register given mapping to this submode when called.
        - If at least one value is supplied, these mappings is registered and this submode is sealed automatically.
- `seal(name)`
    - Seal submode so that additional `submode.default` will be refused.
    - `name: string` Name of target submode.
- `default(name, lhs, rhs, opts)`
    - Add a default mapping to `name`. The default mapping doesn’t change when we calls `submode.set` and `submode.del` for the mapping. Same interface as `vim.keymap.set`.
    - `name: string` Name of target submode.
    - `lhs: string` Lhs of mapping.
    - `rhs: string | fun():string?` Rhs of mapping. Can be function.
    - `opts?: table` Options of this mapping. Same as `opts` of `vim.keymap.set`.
- `set(name, lhs, rhs, opts)`
    - Add a mapping to `name`. Same interface as `vim.keymap.set`.
    - `name: string` Name of target submode.
    - `lhs: string` Lhs of mapping.
    - `rhs: string | fun():string?` Rhs of mapping. Can be function.
    - `opts?: table` Options of this mapping. Same as `opts` of `vim.keymap.set`.
- `del(name, lhs, opts)`
    - Delete a mapping from `name`. Same interface as `vim.keymap.del`.
    - `name: string` Name of target submode.
    - `lhs: string` Lhs of mapping.
    - `opts?: table` Options for this deletion. Same as `opts` of `vim.keymap.del`.
- `enter(name)`
    - Enter the submode. This function only have effect if parent mode of the submode is same as current mode.
    - `name: string` Name of submode to enter.
- `leave()`
    - Leave from current submode. Nothing happen when we are not in submode.
- `mode(): string | nil`
    - Get current submode’s name. Returns nil if not in submode, or `show_mode` is `false`.

Generated by panvimdoc <https://github.com/kdheepak/panvimdoc>

vim:tw=78:ts=8:noet:ft=help:norl:
